<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intense Volume Shader BM</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #eee; font-family: monospace; }
    canvas { display: block; width: 100%; height: 100%; }
    #hud { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px 12px; border-radius: 8px; font-size: 12px; white-space: pre; }
    label { margin-left: 10px; }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <div id="hud">
    FPS: <span id="fps">0</span> | Avg: <span id="avg">0</span> | ms: <span id="ms">0</span>
    <br>
    CPU: <span id="cpu">0</span>% | GPU: <span id="gpu">0</span>% | RAM: <span id="ram">0</span> MB
    <br>
    <label>Scale
      <select id="scale">
        <option value="1">1.00x</option>
        <option value="0.75">0.75x</option>
        <option value="0.5" selected>0.50x</option>
        <option value="0.35">0.35x</option>
        <option value="0.25">0.25x</option>
      </select>
    </label>
    <label>Loops
      <select id="mode">
        <option value="2">2</option>
        <option value="4">4</option>
        <option value="8">8</option>
        <option value="16">16</option>
        <option value="32" selected>32</option>
        <option value="64">64</option>
        <option value="128">128</option>
        <option value="256">256</option>
      </select>
    </label>
    <label>VSync <input type="checkbox" id="vsync" checked></label>
  </div>

<script>
(function(){
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl', { antialias: false });
  if(!gl){ alert('WebGL not available'); return; }

  const vsrc = `
  attribute vec2 a_pos;
  varying vec2 v_uv;
  void main(){
    v_uv = a_pos * 0.5 + 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  const fsrc = `
  precision highp float;
  varying vec2 v_uv;
  uniform vec2 iResolution;
  uniform float iTime;
  uniform int uLoops;

  float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
  float noise(vec2 p){
    vec2 i=floor(p); vec2 f=fract(p);
    vec2 u=f*f*(3.0-2.0*f);
    return mix(mix(hash(i+vec2(0,0)),hash(i+vec2(1,0)),u.x), mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),u.x), u.y);
  }
  float fbm(vec2 p){
    float a=0.0; float w=0.5;
    for(int i=0;i<8;i++){ a+=w*noise(p); p*=2.0; w*=0.5; }
    return a;
  }

  void main(){
    vec2 uv = (v_uv - 0.5) * vec2(iResolution.x/iResolution.y,1.0);
    uv *= 3.0;
    uv.x += iTime*0.3;

    float d = 0.0;
    vec2 p = uv;
    int loops = uLoops;
    for(int i=0;i<256;i++){
      if(i>=loops) break;
      d += fbm(p + iTime*0.05 + float(i)*0.1);
      p *= 1.2;
    }
    d /= float(loops);

    vec3 col = mix(vec3(0.05,0.08,0.2), vec3(0.9,0.3,0.6), d);
    gl_FragColor = vec4(col,1.0);
  }`;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  function makeProgram(vs, fs){
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(prog));
    }
    return prog;
  }

  const prog = makeProgram(compile(gl.VERTEX_SHADER, vsrc), compile(gl.FRAGMENT_SHADER, fsrc));
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  const a_pos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(a_pos);
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  const uRes = gl.getUniformLocation(prog, 'iResolution');
  const uTime = gl.getUniformLocation(prog, 'iTime');
  const uLoops = gl.getUniformLocation(prog, 'uLoops');

  const $fps=document.getElementById('fps');
  const $avg=document.getElementById('avg');
  const $ms=document.getElementById('ms');
  const $scale=document.getElementById('scale');
  const $mode=document.getElementById('mode');
  const $cpu=document.getElementById('cpu');
  const $gpu=document.getElementById('gpu');
  const $ram=document.getElementById('ram');
  const $vsync=document.getElementById('vsync');

  let scale=parseFloat($scale.value);
  $scale.onchange=()=>{ scale=parseFloat($scale.value); resize(); };
  let loops=parseInt($mode.value);
  $mode.onchange=()=>{ loops=parseInt($mode.value); };
  let vsync=$vsync.checked;
  $vsync.onchange=()=>{ vsync=$vsync.checked; startLoop(); };

  function resize(){
    const dpr = Math.min(window.devicePixelRatio||1,1.5);
    canvas.width = Math.floor(innerWidth*scale*dpr);
    canvas.height = Math.floor(innerHeight*scale*dpr);
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  addEventListener('resize', resize);
  resize();

  let t0=performance.now(), frames=0, ema=0; let hist=[];
  let rafId=null, timerId=null;

  function frame(t){
    const frameStart = performance.now();

    const dt = t - t0; 
    t0 = t; 
    frames++;
    ema = ema ? ema*0.9 + dt*0.1 : dt;

    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uTime, t*0.001);
    gl.uniform1i(uLoops, loops);
    gl.drawArrays(gl.TRIANGLES,0,3);

    const frameEnd = performance.now();
    const cpuTime = frameEnd - frameStart;

    if(frames % 15 === 0){
      const fps = 1000/ema;
      $fps.textContent = fps.toFixed(1);
      $ms.textContent = ema.toFixed(2);
      hist.push(fps); if(hist.length>60) hist.shift();
      $avg.textContent = (hist.reduce((a,b)=>a+b,0)/hist.length).toFixed(1);

      const cpuPct = Math.min(100, (cpuTime/ema)*100);
      $cpu.textContent = cpuPct.toFixed(1);

      const gpuPct = Math.min(100, (ema/16.6)*100);
      $gpu.textContent = gpuPct.toFixed(1);

      if(performance.memory){
        $ram.textContent = (performance.memory.usedJSHeapSize/1048576).toFixed(1);
      }
    }

    if(vsync){
      rafId=requestAnimationFrame(frame);
    }
  }

  function startLoop(){
    if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
    if(timerId){ clearTimeout(timerId); timerId=null; }
    if(vsync){
      requestAnimationFrame(frame);
    }else{
      function fastLoop(){
        frame(performance.now());
        timerId=setTimeout(fastLoop,0); // hammer loop, uncapped
      }
      fastLoop();
    }
  }

  startLoop();
})();
</script>
</body>
</html>
